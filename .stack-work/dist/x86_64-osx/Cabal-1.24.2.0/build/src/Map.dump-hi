
==================== FINAL INTERFACE ====================
2017-06-06 20:58:28.350952 UTC

interface librbt-0.1.0.0-1b5tNFuxx0AK0yhfPuFreI:Map 8002
  interface hash: 82da74c103cee1a5114355281c2bf02c
  ABI hash: f56cfc24617de3ae4ab3696b067b2703
  export-list hash: dead972399cf94f8b13d1b61c762c73b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Map.delete
  Map.empty
  Map.fromList
  Map.get
  Map.null
  Map.put
  Map.singleton
  Map.toList
  Map.Map
module dependencies: RBT
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  RBT af4d104703bbb42e9f482736c38a730a
  exports: 44f619b67923ab5e8e4a25a195ddf990
  RBTree e744d26a9a5e91cb5120e15392f133b5
  empty 3d2ca428fabaf1e663372bba23352013
  fromList 5a94c8a1da75ab50eaa2699a85291a91
  insert 55739e7990be25347daa957724cb5e64
  null ff5e2257337f3c43e4a47c121f62128d
  remove ab233c9b4fe5ef56f4446ceb777d7928
  root ecfeab77a5f5ddad4be5919ad7a987f5
  search 324cd0a2a41f0bcdf235efd56323d041
  singleton 289a5361fc768eeaf161e38ce13c877b
  toList f174e8fa6812994b097040806b164ae9
f2596661dbd8891092ac9c11355d0ee3
  $fEqMap :: GHC.Classes.Eq a => GHC.Classes.Eq (Map.Map a b)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b ($dEq :: GHC.Classes.Eq a).
                  @ (Map.Map a b)
                  (Map.$fEqMap_$c== @ a @ b $dEq)
                  (Map.$fEqMap_$c/= @ a @ b $dEq) -}
7c4fa4cdb948b7853db47f5610785188
  $fEqMap1 ::
    GHC.Classes.Eq a =>
    RBT.RBTree (Map.Pair a b)
    -> RBT.RBTree (Map.Pair a b) -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a @ b ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Map.Pair a b) = Map.$fEqPair @ a @ b $dEq
                 } in
                 \ (a1 :: RBT.RBTree (Map.Pair a b))
                   (b1 :: RBT.RBTree (Map.Pair a b)) ->
                 case RBT.$fEqRBTree_$c== @ (Map.Pair a b) $dEq1 a1 b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f62486eb57f8fbf926d4cb0a796726d9
  $fEqMap2 ::
    GHC.Classes.Eq a =>
    RBT.RBTree (Map.Pair a b)
    -> RBT.RBTree (Map.Pair a b) -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b ($dEq :: GHC.Classes.Eq a) ->
                 RBT.$fEqRBTree_$c==
                   @ (Map.Pair a b)
                   (Map.$fEqPair @ a @ b $dEq)) -}
f2596661dbd8891092ac9c11355d0ee3
  $fEqMap_$c/= ::
    GHC.Classes.Eq a => Map.Map a b -> Map.Map a b -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (0, True, True)
                Map.$fEqMap1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Map.N:Map[0] <a>_R <b>_R)
                 ->_R Sym (Map.N:Map[0] <a>_R <b>_R)
                 ->_R <GHC.Types.Bool>_R) -}
f2596661dbd8891092ac9c11355d0ee3
  $fEqMap_$c== ::
    GHC.Classes.Eq a => Map.Map a b -> Map.Map a b -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (0, True, True)
                Map.$fEqMap2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Map.N:Map[0] <a>_R <b>_R)
                 ->_R Sym (Map.N:Map[0] <a>_R <b>_R)
                 ->_R <GHC.Types.Bool>_R) -}
4c48108e67b67ae5fc0374993c235b2b
  $fEqPair :: GHC.Classes.Eq a => GHC.Classes.Eq (Map.Pair a b)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b ($dEq :: GHC.Classes.Eq a).
                  @ (Map.Pair a b)
                  (Map.$fEqPair_$c== @ a @ b $dEq)
                  (Map.$fEqPair_$c/= @ a @ b $dEq) -}
4c48108e67b67ae5fc0374993c235b2b
  $fEqPair_$c/= ::
    GHC.Classes.Eq a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 GHC.Classes.not (Map.$fEqPair_$c== @ a @ b $dEq x y)) -}
4c48108e67b67ae5fc0374993c235b2b
  $fEqPair_$c== ::
    GHC.Classes.Eq a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Map.Pair a b)
                   (ds1 :: Map.Pair a b) ->
                 case ds `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild { (,) a1 b1 ->
                 case ds1 `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) c d ->
                 GHC.Classes.== @ a $dEq a1 c } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair :: GHC.Classes.Ord a => GHC.Classes.Ord (Map.Pair a b)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b ($dOrd :: GHC.Classes.Ord a).
                  @ (Map.Pair a b)
                  (Map.$fOrdPair_$cp1Ord @ a @ b $dOrd)
                  (Map.$fOrdPair_$ccompare @ a @ b $dOrd)
                  (Map.$fOrdPair_$c< @ a @ b $dOrd)
                  (Map.$fOrdPair_$c<= @ a @ b $dOrd)
                  (Map.$fOrdPair_$c> @ a @ b $dOrd)
                  (Map.$fOrdPair_$c>= @ a @ b $dOrd)
                  (Map.$fOrdPair_$cmax @ a @ b $dOrd)
                  (Map.$fOrdPair_$cmin @ a @ b $dOrd) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$c< ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLL),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 case Map.$fOrdPair_$ccompare @ a @ b $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$c<= ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (ds :: Map.Pair a b)
                   (ds1 :: Map.Pair a b) ->
                 case ds `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild { (,) a1 b1 ->
                 case ds1 `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) c d ->
                 GHC.Classes.<= @ a $dOrd a1 c } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$c> ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLL),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 case Map.$fOrdPair_$ccompare @ a @ b $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$c>= ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLL),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 case Map.$fOrdPair_$ccompare @ a @ b $dOrd x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$ccompare ::
    GHC.Classes.Ord a =>
    Map.Pair a b -> Map.Pair a b -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Ord a)
                   (w1 :: Map.Pair a b)
                   (w2 :: Map.Pair a b) ->
                 case w1 `cast` (Map.N:Pair[0] <a>_N <b>_N) of ww { (,) ww1 ww2 ->
                 case w2 `cast` (Map.N:Pair[0] <a>_N <b>_N) of ww3 { (,) ww4 ww5 ->
                 Map.$w$ccompare @ a @ b w ww1 ww4 } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$cmax ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> Map.Pair a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 case x `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild { (,) a1 b1 ->
                 case y `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) c d ->
                 case GHC.Classes.<= @ a $dOrd a1 c of wild2 {
                   GHC.Types.False -> wild `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                   GHC.Types.True
                   -> wild1 `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N) } } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$cmin ::
    GHC.Classes.Ord a => Map.Pair a b -> Map.Pair a b -> Map.Pair a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Map.Pair a b)
                   (y :: Map.Pair a b) ->
                 case x `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild { (,) a1 b1 ->
                 case y `cast` (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) c d ->
                 case GHC.Classes.<= @ a $dOrd a1 c of wild2 {
                   GHC.Types.False -> wild1 `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                   GHC.Types.True
                   -> wild `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N) } } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fOrdPair_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Map.Pair a b)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b ($dOrd :: GHC.Classes.Ord a) ->
                 Map.$fEqPair @ a @ b (GHC.Classes.$p1Ord @ a $dOrd)) -}
f2596661dbd8891092ac9c11355d0ee3
  $fShowMap ::
    (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Map.Map a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show b)
                      ($dShow1 :: GHC.Show.Show a).
                  @ (Map.Map a b)
                  (Map.$fShowMap_$cshowsPrec @ a @ b $dShow $dShow1)
                  (Map.$fShowMap_$cshow @ a @ b $dShow $dShow1)
                  (Map.$fShowMap_$cshowList @ a @ b $dShow $dShow1) -}
5e911eb3c44dc71ba7f2abdbbc88e86e
  $fShowMap1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
ad5b580d429b8c3ca3caeb24d7490408
  $fShowMap2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Map "#) -}
62d4c6d78ec43aa991476eb3d1c72780
  $fShowMap3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
f2596661dbd8891092ac9c11355d0ee3
  $fShowMap_$cshow ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    Map.Map a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: Map.Map a b) ->
                 Map.$fShowMap_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f2596661dbd8891092ac9c11355d0ee3
  $fShowMap_$cshowList ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    [Map.Map a b] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a) ->
                 GHC.Show.showList__
                   @ (Map.Map a b)
                   (Map.$fShowMap_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      Map.$fShowMap1)) -}
f2596661dbd8891092ac9c11355d0ee3
  $fShowMap_$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> Map.Map a b -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>,
     Unfolding: (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a) ->
                 let {
                   $dShow2 :: GHC.Show.Show (Map.Pair a b)
                   = Map.$fShowPair @ a @ b $dShow1 $dShow
                 } in
                 \ (a1 :: GHC.Types.Int) (ds :: Map.Map a b) ->
                 case a1 of wild { GHC.Types.I# x ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = RBT.$fShowRBTree_$cshowsPrec
                       @ (Map.Pair a b)
                       $dShow2
                       Map.$fShowMap3
                       ds `cast` (Map.N:Map[0] <a>_R <b>_R)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x 11#) of wild1 {
                   GHC.Types.False
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Map.$fShowMap2 (g x1)
                   GHC.Types.True
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Map.$fShowMap2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x1))) } }) -}
4c48108e67b67ae5fc0374993c235b2b
  $fShowPair ::
    (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Map.Pair a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show a)
                      ($dShow1 :: GHC.Show.Show b).
                  @ (Map.Pair a b)
                  (Map.$fShowPair_$cshowsPrec @ a @ b $dShow $dShow1)
                  (Map.$fShowPair_$cshow @ a @ b $dShow $dShow1)
                  (Map.$fShowPair_$cshowList @ a @ b $dShow $dShow1) -}
671d29eaed624df0fe1746602c103340
  $fShowPair1 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4c48108e67b67ae5fc0374993c235b2b
  $fShowPair_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    Map.Pair a b -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShow(,)_$cshow
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Show.Show a>_R
                 ->_R <GHC.Show.Show b>_R
                 ->_R Sym (Map.N:Pair[0]) <a>_N <b>_N
                 ->_R <GHC.Base.String>_R) -}
4c48108e67b67ae5fc0374993c235b2b
  $fShowPair_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    [Map.Pair a b] -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (ls :: [Map.Pair a b])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Map.Pair a b)
                   (\ (x :: Map.Pair a b) (s1 :: GHC.Base.String)[OneShot] ->
                    case x `cast` (Map.N:Pair[0] <a>_N <b>_N) of ww { (,) ww1 ww2 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows7
                         (GHC.Show.showsPrec
                            @ a
                            $dShow
                            GHC.Show.shows22
                            ww1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows5
                               (GHC.Show.$fShow(,)_$sgo
                                  Map.$fShowPair1
                                  (GHC.Show.showsPrec @ b $dShow1 GHC.Show.shows22 ww2)
                                  (GHC.Types.[] @ GHC.Show.ShowS)))))
                      s1 })
                   ls
                   s) -}
4c48108e67b67ae5fc0374993c235b2b
  $fShowPair_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Types.Int -> Map.Pair a b -> GHC.Show.ShowS
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,A><S,1*U(U,U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Types.Int)
                   (w3 :: Map.Pair a b)
                   (w4 :: GHC.Base.String) ->
                 case w3 `cast` (Map.N:Pair[0] <a>_N <b>_N) of ww { (,) ww1 ww2 ->
                 Map.$w$cshowsPrec @ a @ b w w1 ww1 ww2 w4 }) -}
e5bc76f0bcec50108356d9168f4a0613
  $tc'Map :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4690202676637248572##
                   10043551104365726377##
                   Map.$trModule
                   Map.$tc'Map1) -}
39722abeedf66492c87022b9376d2c25
  $tc'Map1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Map"#) -}
05e94a62b43d95d0b215ab4ba1f3f29f
  $tc'Pair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1251070151502867121##
                   8580900042882797539##
                   Map.$trModule
                   Map.$tc'Pair1) -}
f7fcc40428c0f3f7b38d392f69a3748f
  $tc'Pair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pair"#) -}
78120f1df0d27bd7cd39fe9fc35d9bef
  $tcMap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12884907374667303960##
                   5136961986821523271##
                   Map.$trModule
                   Map.$trModule1) -}
207ea8807a2b62658c4a360c0f2e668f
  $tcPair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   427105523167571858##
                   8558414336240726890##
                   Map.$trModule
                   Map.$tcPair1) -}
3590cda509872a0eadfcdede26468fae
  $tcPair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Pair"#) -}
4e232a098d5eeb7eabc847c52d23e43b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Map.$trModule2 Map.$trModule1) -}
d468d2e742160327d80e76e566b8d642
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Map"#) -}
6100da9fd8114b7c7476bb02b09f0b0b
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "librbt-0.1.0.0-1b5tNFuxx0AK0yhfPuFreI"#) -}
e47f95fcba054d122901ea5fed0158ed
  $w$ccompare :: GHC.Classes.Ord a => a -> a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Ord a)
                   (ww :: a)
                   (ww1 :: a) ->
                 case GHC.Classes.== @ a (GHC.Classes.$p1Ord @ a w) ww ww1 of wild {
                   GHC.Types.False
                   -> case GHC.Classes.<= @ a w ww ww1 of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                   GHC.Types.True -> GHC.Types.EQ }) -}
cf197ef7274b0e38a2f1f60973347a7a
  $w$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    a -> b -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (ww :: a)
                   (ww1 :: b)
                   (w2 :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows7
                      (GHC.Show.showsPrec
                         @ a
                         w
                         GHC.Show.shows22
                         ww
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows5
                            (GHC.Show.$fShow(,)_$sgo
                               Map.$fShowPair1
                               (GHC.Show.showsPrec @ b w1 GHC.Show.shows22 ww1)
                               (GHC.Types.[] @ GHC.Show.ShowS)))))
                   w2) -}
f2596661dbd8891092ac9c11355d0ee3
  newtype Map a b = Map (RBT.RBTree (Map.Pair a b))
4c48108e67b67ae5fc0374993c235b2b
  newtype Pair a b = Pair {getPair :: (a, b)}
b5493da9c1de8a15e84b413aa896bbfd
  delete :: GHC.Classes.Ord a => a -> Map.Map a b -> Map.Map a b
  {- Arity: 1, Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a @ b ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord (Map.Pair a b)
                   = Map.$fOrdPair @ a @ b $dOrd
                 } in
                 \ (x :: a) (m :: Map.Map a b) ->
                 case m `cast` (Map.N:Map[0] <a>_R <b>_R) of wild {
                   RBT.Empty
                   -> (RBT.Empty @ (Map.Pair a b))
                        `cast`
                      (Sym (Map.N:Map[0] <a>_R <b>_R))
                   RBT.Node ds1 x1 ds2 ds3
                   -> case x1
                             `cast`
                           (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) ds y ->
                      (RBT.remove
                         @ (Map.Pair a b)
                         $dOrd1
                         (x, y) `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                         wild)
                        `cast`
                      (Sym (Map.N:Map[0] <a>_R <b>_R)) } }) -}
d25f4e3eb7f63f0b9d2b9c6ecdda3412
  empty :: Map.Map a b
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> RBT.Empty @ (Map.Pair a b))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (Map.N:Map[0] <a>_R <b>_R)) -}
86cef22a83c5285b694b6110754802c5
  fromList :: GHC.Classes.Ord a => [(a, b)] -> Map.Map a b
  {- Arity: 1, Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   f :: GHC.Classes.Ord (Map.Pair a b) = Map.$fOrdPair @ a @ b $dOrd
                 } in
                 (\ (x :: [(a, b)]) ->
                  RBT.fromList
                    @ (Map.Pair a b)
                    f
                    x `cast` ([Sym (Map.N:Pair[0]) <a>_N <b>_N])_R)
                   `cast`
                 (<[(a, b)]>_R ->_R Sym (Map.N:Map[0] <a>_R <b>_R))) -}
6727853d20bf844b9448bf467d47a945
  get :: GHC.Classes.Ord a => a -> Map.Map a b -> GHC.Base.Maybe b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a @ b ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord (Map.Pair a b)
                   = Map.$fOrdPair @ a @ b $dOrd
                 } in
                 \ (x :: a) (ds :: Map.Map a b) ->
                 case ds `cast` (Map.N:Map[0] <a>_R <b>_R) of wild {
                   RBT.Empty -> GHC.Base.Nothing @ b
                   RBT.Node ds1 x1 ds2 ds3
                   -> case x1
                             `cast`
                           (Map.N:Pair[0] <a>_N <b>_N) of wild1 { (,) ds4 y ->
                      case RBT.search
                             @ (Map.Pair a b)
                             $dOrd1
                             (x, y) `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                             wild of wild2 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ b
                        GHC.Base.Just x2
                        -> case x2
                                  `cast`
                                (Map.N:Pair[0] <a>_N <b>_N) of wild3 { (,) ds5 a1 ->
                           GHC.Base.Just @ b a1 } } } }) -}
836115720aefb46725a2098961b3bc9c
  getPair :: Map.Pair a b -> (a, b)
  RecSel Left Map.Pair
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Map.getPair1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Map.Pair a b>_R ->_R Map.N:Pair[0] <a>_N <b>_N) -}
0ca859ff78bccc38a9f5287c66dc6854
  getPair1 :: Map.Pair a b -> Map.Pair a b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: Map.Pair a b) -> ds) -}
78fe529ff8a48c8910395f9ccbe0a168
  null :: Map.Map a b -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: Map.Map a b) ->
                 RBT.null @ (Map.Pair a b) ds `cast` (Map.N:Map[0] <a>_R <b>_R)) -}
b975dd894f243077513572e166fc69ad
  put :: GHC.Classes.Ord a => a -> b -> Map.Map a b -> Map.Map a b
  {- Arity: 1, Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a @ b ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord (Map.Pair a b)
                   = Map.$fOrdPair @ a @ b $dOrd
                 } in
                 (\ (k :: a) (v :: b) (ds :: Map.Map a b) ->
                  case RBT.$winsert
                         @ (Map.Pair a b)
                         $dOrd1
                         (k, v) `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                         ds
                           `cast`
                         (Map.N:Map[0] <a>_R <b>_R) of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                  RBT.Node @ (Map.Pair a b) ww1 ww2 ww3 ww4 })
                   `cast`
                 (<a>_R
                  ->_R <b>_R
                  ->_R <Map.Map a b>_R
                  ->_R Sym (Map.N:Map[0] <a>_R <b>_R))) -}
1389f2114294f56094ec0dd0276d7caa
  singleton :: a -> b -> Map.Map a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Map.singleton1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R ->_R <b>_R ->_R Sym (Map.N:Map[0] <a>_R <b>_R)) -}
18f76f282d4e8f026a501a891d121cec
  singleton1 :: a -> b -> RBT.RBTree (Map.Pair a b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: a) (b1 :: b) ->
                 RBT.Node
                   @ (Map.Pair a b)
                   RBT.Black
                   (a1, b1) `cast` (Sym (Map.N:Pair[0]) <a>_N <b>_N)
                   (RBT.Empty @ (Map.Pair a b))
                   (RBT.Empty @ (Map.Pair a b))) -}
5b92919d5e84c81c2fd3fe48030ecbf1
  toList :: Map.Map a b -> [(a, b)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Map.toList1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 Sym (Map.N:Map[0] <a>_R <b>_R)
                 ->_R ([Map.N:Pair[0] <a>_N <b>_N])_R) -}
9fb36630c4727b7efa10c2023649553f
  toList1 :: RBT.RBTree (Map.Pair a b) -> [Map.Pair a b]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: RBT.RBTree (Map.Pair a b)) ->
                 (RBT.$fFoldableRBTree_$cfoldMap
                    @ (Data.Monoid.Endo [Map.Pair a b])
                    @ (Map.Pair a b)
                    (Data.Monoid.$fMonoidEndo @ [Map.Pair a b])
                    (GHC.Types.: @ (Map.Pair a b))
                      `cast`
                    (<Map.Pair a b>_R
                     ->_R Sym (Data.Monoid.N:Endo[0] <[Map.Pair a b]>_R))
                    x)
                   `cast`
                 (Data.Monoid.N:Endo[0] <[Map.Pair a b]>_R)
                   (GHC.Types.[] @ (Map.Pair a b))) -}
instance [safe] GHC.Classes.Eq [Map.Map] = Map.$fEqMap
instance [safe] GHC.Classes.Eq [Map.Pair] = Map.$fEqPair
instance [safe] GHC.Classes.Ord [Map.Pair] = Map.$fOrdPair
instance [safe] GHC.Show.Show [Map.Map] = Map.$fShowMap
instance [safe] GHC.Show.Show [Map.Pair] = Map.$fShowPair
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

